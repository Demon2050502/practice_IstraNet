### 1. Почему для backend выбран Go?

В качестве backend-языка был выбран **Go (Golang)**. Так как я начинал учить Go, после знание базы языка програмирование С. Из-за этого, мне больше нравиться строгая типизация и управлением ресурсами приложение.

Основные причины выбора:

- **Производительность.** Go является низкоуровневым компилируемым языком, который работает близко к системным ресурсам. Это позволяет эффективно использовать память и процессор, обеспечивать высокую скорость обработки запросов и стабильную работу сервера даже при большом количестве одновременных подключений.
- **Удобство деплоя.** Go-приложение собирается в один бинарный файл.
- **Строгая типизация.** Позволяет лучше контролировать структуры данных (DTO, модели) и уменьшать количество ошибок при работе с API.

---

### 2. Где находится бизнес-логика, а где обработка HTTP-запросов?

В проекте предполагается разделение ответственности между слоями:

- **HTTP-слой (`handler`)**

  - принимает HTTP-запросы (REST);
  - читает данные из запроса (JSON / query / params);
  - делает базовую проверку формата (например: пустые поля, неверный тип);
  - формирует HTTP-ответ (JSON + статус-код).

- **Слой бизнес-логики (`service`)**

  - выполняет проверки прав доступа по роли (user / operator / admin);
  - управляет процессом обработки заявки (создание → назначение → изменение статуса → закрытие);
  - при необходимости формирует записи истории изменений;
  - обращается к слою данных через интерфейсы репозитория.

- **Слой доступа к данным (`repository`)**
  - содержит SQL-запросы и работу с PostgreSQL;
  - отвечает за сохранение и получение данных (users, applications, history);
  - не содержит бизнес-логики (только CRUD и выборки).

Таким образом:
**handler** = транспорт (HTTP),  
**service** = логика и правила,  
**repository** = база данных и SQL.

---

### 3. Процесс обработки одной заявки (шагами)

1. Пользователь авторизуется в системе и получает JWT-токен.
2. Пользователь создаёт заявку через API создания обращений.
3. Заявка сохраняется в базе данных со статусом `new`.
4. Оператор получает список доступных заявок.
5. Оператор берёт заявку в работу — заявке назначается исполнитель и статус меняется на `in_progress`.
6. В процессе обработки оператор может:
   - менять статус заявки;
   - добавлять комментарии;
7. После решения проблемы оператор закрывает заявку (статус `closed` или `resolved`).
8. Все изменения фиксируются в истории заявки.

---

### 4. Минимальный функционал (MVP)

**Авторизация**

- `POST /api/auth/sign-in`
- `POST /api/auth/sign-up`  
  Необходима для определения роли пользователя и проверки прав доступа.

**Пользователь**

- `POST /api/user/applications/create-app` — создание заявки.
- `GET /api/user/applications/get-apps` — просмотр списка своих заявок. - я думаю это нужно для просмотра и удостоверние пользователя, что заявка была отправленна.(только для минимального функционала я сделаю чтобы она отправляло все данные заявки, а не частичные как было раньше)

**Оператор**

- `GET /api/operator/applications/get-apps` — список заявок.
- `PUT /api/operator/applications/take-app` — взять заявку в работу.
- `PUT /api/operator/applications/change-status` — изменить статус.
- `PUT /api/operator/applications/close-app` — закрыть заявку.
- этого набора должно хватить чтобы заявка прошла по всем этапам.

**Админ**

- Я думаю он не нужен при минимальном функционале

---

### 5. Потенциальные проблемы при росте проекта

Сейчас основная проблема в том, что в если начнёт разрастаться набор “вспомогательных функций”, которые легко превратятся в неструктурированную “помойку” с зависимостями “всё от всего”; и, если появится командная разработка, возрастут конфликты в файлах, дублирование логики и разнобой в подходах.



# Архитектура (без усложнения)

Проект логически делится на три слоя:

- **handler (HTTP-слой)** — принимает запросы и возвращает ответы.
- **service (бизнес-логика)** — решает, что можно/нельзя делать по правилам системы.
- **repository (доступ к данным)** — читает/пишет данные в PostgreSQL (SQL/CRUD), без бизнес-логики.

---

## Пример сценария: оператор берёт заявку в работу (`take-app`)

### 1) Что происходит при запросе (handler)

`PUT /api/operator/applications/take-app`

- Запрос приходит с JWT-токеном.
- Handler:
  - достаёт `operatorID` из токена;
  - читает `application_id`;
  - делает базовую проверку формата (например, `application_id > 0`);
  - вызывает бизнес-логику: `service.TakeApp(operatorID, applicationID)`;
  - возвращает HTTP-ответ (JSON + статус-код).

### 2) Где принимается решение (service)

Service выполняет правила:

- проверяет, что роль пользователя — `operator`;
- проверяет статус заявки:
  - если статус не `new`, то взять в работу нельзя;
- если всё корректно:
  - назначает исполнителя = `operatorID`;
  - меняет статус на `in_progress`;
  - при необходимости формирует запись в истории изменений.

### 3) Где происходит работа с базой (repository)

Repository делает только операции с базой данных:

- получить заявку: `GetApplicationByID(applicationID)`
- обновить исполнителя и статус: `UpdateExecutorAndStatus(applicationID, operatorID, "in_progress")`
- записать историю: `InsertHistory(applicationID, operatorID, "take_app", ...)`
